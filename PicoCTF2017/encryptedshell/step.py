from hashlib import sha256
from Crypto import Random
from Crypto.Random import random
from Crypto.Cipher import AES


BLOCK_SIZE = 16
R = Random.new()

def pad(m):
    o = BLOCK_SIZE - len(m) % BLOCK_SIZE
    return m + o * chr(o)

def unpad(p):
    return p[0:-ord(p[-1])]

def send_encrypted(KEY, m):
    IV = R.read(BLOCK_SIZE)
    aes = AES.new(KEY, AES.MODE_CBC, IV)
    c = aes.encrypt(pad(m))
    print (IV + c).encode('hex')

def read_encrypted(KEY, m):
    data = m.decode('hex')
    IV, data = data[:BLOCK_SIZE], data[BLOCK_SIZE:]
    aes = AES.new(KEY, AES.MODE_CBC, IV)
    m = unpad(aes.decrypt(data))
    return m


def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


p = 174807157365465092731323561678522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843
g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977
A = 49328183005174339219065565313828966417045193088638120053918215321010951835300705516452396623343805584758620954564114577415813087206713722257483332074907010208375394891372106513275423125113887380154045940018944754488027695723522881139660509353823631557616700415221598969561490112998301578923776574119707118769

h = pow(g, 2**23, p)
y = modinv(h,p)


table = {}
pre = pow(g,1,p)
table[pre] = 1
for i in range(2,2**23):
    j = (g * pre) % p
    table[j] = i
    pre = j
    if(i % 1000000 == 0):
        print(i)

out1, out2 = 0,0

for i in range(1,2**23):
    if(table.get(A)):
        out1, out2 = table[A], i-1
        break
    else:
        A = (y * A) % p
A = 49328183005174339219065565313828966417045193088638120053918215321010951835300705516452396623343805584758620954564114577415813087206713722257483332074907010208375394891372106513275423125113887380154045940018944754488027695723522881139660509353823631557616700415221598969561490112998301578923776574119707118769
B = 52212067689594112109323640929301351606467118203383150327599211883168430054342124696361946771882317563613814253170561126339826644357001686458446188458014200762135544004281320619787980315833659890517041361133454035724795056335268420608527814057585862519036050687522158793940953574062642063690400491833858296879
print out1, out2
a = out1 + 2 **23 * out2
assert pow(g, a, p) == A

sharedkey = sha256(str(pow(B, a, p))).digest()

print(read_encrypted(sharedkey, "1a30a68af458370dfdcbbe6fb7112bf20488eea7f1203ffbb6510879ed71e79186bb45643e269e638b36d2102e130f3cc6c520a58f2ed892693f967b1be7783b"))
print(read_encrypted(sharedkey, "b2fc17364b894f756bb6ddebf46a77861043e5a227c6ec9bdc255a72039288826089de6123684c0dfc8daccbfa1a9708"))
print(read_encrypted(sharedkey, "2879e7a568a59dd75ca0132099f397db6ca6b44af7710e794fe047d94f3eaff58257f030132b3d03c2c754312c79074b"))
print(read_encrypted(sharedkey, "b78b97c8b6fcf6ae2d2dda2db7009394843bd98035fdfcc86602cf12af9a10a1"))
print(read_encrypted(sharedkey, "dceeebdafdaa6baa4a05c701ba2eb878aba4531f4cf13a9f7e2b8a9d2b1c7992"))
