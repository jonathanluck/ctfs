from Crypto.PublicKey import RSA
from Crypto.Cipher import AES,PKCS1_OAEP
from fractions import gcd

#https://github.com/blockstack/secret-sharing
from secretsharing import PlaintextToHexSecretSharer

#https://github.com/vik001ind/RSAExploits
import RSAExploits

#egcd and modinv from http://stackoverflow.com/a/9758173
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

#taken from encryption.py
def decrypt(private_key, ciphertext):
  """Decrypt a message with a given private key.

  Takes in a private_key generated by Crypto.PublicKey.RSA, which must be of
  size exactly 4096

  If the ciphertext is invalid, return None
  """
  if len(ciphertext) < 512 + 16:
    return None
  msg_header = ciphertext[:512]
  msg_iv = ciphertext[512:512+16]
  msg_body = ciphertext[512+16:]
  try:
    symmetric_key = PKCS1_OAEP.new(private_key).decrypt(msg_header)
  except ValueError:
    return None
  if len(symmetric_key) != 32:
    return None
  return AES.new(symmetric_key,
      mode=AES.MODE_CFB,
      IV=msg_iv).decrypt(msg_body)

#get all the encoded public keys
a = [open("key-{}.pem".format(i)).read() for i in range(10)]

#turn them into usuable public keys
b = [RSA.importKey(k) for k in a]

#get all their moduli
n = [pk.key.n for pk in b]

#read all the ciphertexts
cts = [open("ciphertext-{}.bin".format(i), 'rb').read() for i in range(1,6)]

#list that we will add our decrypted "plaintexts" to
plaintexts = []


#first decryption: common factor
n1 = 1
p1 = 1
q1 = 1
e1 = 1

#loop through every pair of moduli checking for common factors.
#If we find one, use it to decrypt a message
for i in range(10):
    for j in range(i+1, 10):
        if(gcd(n[i], n[j]) != 1):
            n1 = n[i]
            e1 = b[i].key.e
            p1 = gcd(n[i], n[j])
            q1 = n1 / p1
            break

assert p1 * q1 == n1
tot1 = n1 - (p1 + q1 - 1)
d1 = modinv(e1, tot1)
privkey1 = RSA.construct((n1, e1, d1))
#decrypt a ciphertext
for c in cts:
    temp = decrypt(privkey1, c)
    if(temp):
        plaintexts.append(temp)
        break


#next up is fermat factorization
f = []
for k in b:
	f.append(RSAExploits.rsa_obj(k.key.n, k.key.e))
y = [RSAExploits.RSAData(i) for i in f]
ferm = RSAExploits.Fermat()
ferm.run(y)

n2 = 1
p2 = 1
q2 = 1
e2 = 1
for data in y:
    if(data.get_p()):
        n2 = data.get_n()
        p2 = data.get_p()
        q2 = data.get_q()
        e2 = data.get_e()

assert p2 * q2 == n2
tot2 = n2 - (p2 + q2 - 1)
d2 = modinv(e2, tot2)
privkey2 = RSA.construct((n2, e2, d2))


for c in cts:
    temp = decrypt(privkey2, c)
    if(temp):
        plaintexts.append(temp)
        break



w = RSAExploits.Wiener()
#we know to run it only on key-3.pem because the public exponent in that key is very large
w.run([y[3]])

n3 = n[3]
p3 = y[3].get_p()
q3 = y[3].get_q()
e3 = b[3].key.e
assert p3 * q3 == n3

tot3 = n3 - (p3 + q3 - 1)
d3 = modinv(e3, tot3)
privkey3 = RSA.construct((n3, e3, d3))
for c in cts:
    temp = decrypt(privkey3, c)
    if(temp):
        plaintexts.append(temp)
        break
#cut off the congratulations messages and break up each line
pt1 = plaintexts[0].strip().split("\n")[1:]
pt2 = plaintexts[1].strip().split("\n")[1:]
pt3 = plaintexts[2].strip().split("\n")[1:]

#zip them together and recover the secret.
#zipped so we can combine pt1[n] pt2[n] and pt3[n] easily 
for i in zip(pt1, pt2, pt3):
    print(PlaintextToHexSecretSharer.recover_secret(i))
